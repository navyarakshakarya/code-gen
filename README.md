# code-gen - Go Clean Architecture Code Generator

A powerful command-line tool that automatically analyzes Go projects and generates clean architecture implementations with interface patterns and struct factories, similar to Google's Wire.

[![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.19-blue.svg)](https://golang.org/)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)

## üöÄ Installation

Install directly using `go install`:

\`\`\`bash
go install github.com/your-org/code-gen@latest
\`\`\`

## ‚ú® Features

- üîç **Automatic Analysis**: Scans your Go project and identifies interfaces and structs
- üèóÔ∏è **Clean Architecture**: Generates repository, use case, and handler implementations
- üè≠ **Factory Pattern**: Creates centralized dependency injection
- üîå **Wire Integration**: Generates Google Wire compatible providers
- üìù **Best Practices**: Follows Go conventions and clean code principles
- üöÄ **Zero Configuration**: Works out of the box with minimal setup
- üíª **Build Tags Support**: Respects Go build constraints

## üìñ Usage

### Basic Usage

Navigate to your Go project directory and run:

\`\`\`bash
code-gen
\`\`\`

### Advanced Options

\`\`\`bash
# Enable verbose output
code-gen -verbose

# Preview what would be generated (dry run)
code-gen -dry-run

# Force overwrite existing files
code-gen -force

# Include specific build tags
code-gen -tags "integration,dev"

# Specify output directory
code-gen -output ./generated

# Show help
code-gen -help

# Show version
code-gen -version
\`\`\`

## üèóÔ∏è Architecture

The tool automatically detects and generates code for three main architectural layers:

### Repository Layer
- **Pattern**: `*Repo`, `*Repository`
- **Purpose**: Data access layer
- **Dependencies**: Database connections
- **Generated**: CRUD operations with database integration

### Use Case Layer  
- **Pattern**: `*UseCase`, `*Service`
- **Purpose**: Business logic layer
- **Dependencies**: Repository interfaces
- **Generated**: Business operations with repository calls

### Handler Layer
- **Pattern**: `*Handler`, `*Controller`
- **Purpose**: Presentation layer
- **Dependencies**: Use case interfaces
- **Generated**: HTTP handlers with use case integration

## üìù Example

Given these interfaces in your Go project:

\`\`\`go
package main

import (
    "context"
    "github.com/gofiber/fiber/v2"
)

type User struct {
    ID       int    `json:"id"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

type UserRepo interface {
    GetByID(ctx context.Context, id int) (User, error)
    Create(ctx context.Context, user User) (User, error)
}

type UserUseCase interface {
    GetProfile(ctx context.Context, userID int) (User, error)
    CreateUser(ctx context.Context, user User) (User, error)
}

type UserHandler interface {
    GetProfile(c *fiber.Ctx) error
    CreateUser(c *fiber.Ctx) error
}
\`\`\`

Running `code-gen` generates:

### `user_repository.gen.go`
\`\`\`go
// Code generated by code-gen. DO NOT EDIT.

package main

import (
    "context"
    "database/sql"
    "fmt"
)

// userRepo implements UserRepo interface
type userRepo struct {
    db *sql.DB
}

// NewUserRepo creates a new instance of userRepo
func NewUserRepo(db *sql.DB) UserRepo {
    return &userRepo{
        db: db,
    }
}

func (impl *userRepo) GetByID(ctx context.Context, id int) (User, error) {
    // TODO: Implement GetByID
    // Example database operation:
    // query := "SELECT * FROM table WHERE condition = ?"
    // rows, err := impl.db.QueryContext(ctx, query, param)
    // if err != nil {
    //     return result, fmt.Errorf("database query failed: %w", err)
    // }
    // defer rows.Close()
    return User{}, nil
}

func (impl *userRepo) Create(ctx context.Context, user User) (User, error) {
    // TODO: Implement Create
    return User{}, nil
}

// Ensure userRepo implements UserRepo
var _ UserRepo = (*userRepo)(nil)
\`\`\`

### `user_usecase.gen.go`
\`\`\`go
// Code generated by code-gen. DO NOT EDIT.

package main

import (
    "context"
    "fmt"
)

// userUseCase implements UserUseCase interface
type userUseCase struct {
    repo UserRepo
}

// NewUserUseCase creates a new instance of userUseCase
func NewUserUseCase(repo UserRepo) UserUseCase {
    return &userUseCase{
        repo: repo,
    }
}

func (impl *userUseCase) GetProfile(ctx context.Context, userID int) (User, error) {
    // TODO: Implement GetProfile
    // Example business logic:
    // 1. Validate input parameters
    // 2. Call repository methods
    // 3. Apply business rules
    // 4. Return processed result
    return User{}, nil
}

func (impl *userUseCase) CreateUser(ctx context.Context, user User) (User, error) {
    // TODO: Implement CreateUser
    return User{}, nil
}

// Ensure userUseCase implements UserUseCase
var _ UserUseCase = (*userUseCase)(nil)
\`\`\`

### `factory.gen.go`
\`\`\`go
// Code generated by code-gen. DO NOT EDIT.

package main

import (
    "database/sql"
    "context"
)

// Factory provides centralized dependency injection
type Factory struct {
    db     *sql.DB
    ctx    context.Context
    config *Config
}

// NewFactory creates a new factory instance
func NewFactory(db *sql.DB, ctx context.Context, config *Config) *Factory {
    return &Factory{
        db:     db,
        ctx:    ctx,
        config: config,
    }
}

// NewUserRepo creates a new UserRepo instance with dependencies
func (f *Factory) NewUserRepo() UserRepo {
    return NewUserRepo(f.db)
}

// NewUserUseCase creates a new UserUseCase instance with dependencies
func (f *Factory) NewUserUseCase() UserUseCase {
    repo := f.NewUserRepo()
    return NewUserUseCase(repo)
}

// NewUserHandler creates a new UserHandler instance with dependencies
func (f *Factory) NewUserHandler() UserHandler {
    useCase := f.NewUserUseCase()
    return NewUserHandler(useCase)
}
\`\`\`

### `wire.gen.go` (Google Wire Integration)
\`\`\`go
// Code generated by code-gen. DO NOT EDIT.
//go:build wireinject
// +build wireinject

package main

import (
    "database/sql"
    "context"
    "github.com/google/wire"
)

// ProviderSet is the Wire provider set for dependency injection
var ProviderSet = wire.NewSet(
    NewUserRepo,
    NewUserUseCase,
    NewUserHandler,
    NewFactory,
)

// InitializeUserHandler creates a fully wired UserHandler instance
func InitializeUserHandler(db *sql.DB, ctx context.Context, config *Config) (UserHandler, error) {
    wire.Build(ProviderSet)
    return nil, nil // Wire will generate the implementation
}
\`\`\`

## üîß Integration with Build Tools

### Makefile Integration
```makefile
.PHONY: generate
generate:
	@echo "Generating clean architecture code..."
	@code-gen -verbose
	@echo "Running go mod tidy..."
	@go mod tidy
	@echo "Code generation complete!"

.PHONY: generate-force
generate-force:
	@code-gen -force -verbose
	@go mod tidy
